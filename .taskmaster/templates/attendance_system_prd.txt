<context>
# Overview
The School Attendance System is a multi-tenant Flutter mobile application for iOS and Android, designed to streamline attendance tracking for educational institutions. Each institution (school or organization) operates within its own isolated instance. The system provides role-based access control, real-time attendance management, statistical analysis, and reporting capabilities using Firebase as the backend infrastructure. Users are required to select their institution before logging in.

The target users for this system are:
- **Class Representatives**: Students designated to take attendance for their assigned classes.
- **Supervisors**: Teachers or staff who can manage and view attendance across multiple classes.
- **Stakeholders**: Parents, guardians, or authorized personnel who can view attendance for specific classes.
- **Administrators**: System administrators with full control over users and system settings within their institution.

# Core Features
- **User Management System**: Role-based permissions for Class Reps, Supervisors, Stakeholders, and Administrators.
- **Student Management**: A comprehensive student database with required information (ID, name, class) and optional details (profile picture, contact info). Admins can add, update, and manage student records.
- **Attendance Management**: A flexible system for taking attendance with selectable dates, various status options (Present, Absent, Late, etc.), and real-time submission.
- **Dashboard and Analytics**: A statistical dashboard providing an overview of attendance trends, present/absent ratios, and class-wise comparisons through charts and visualizations.
- **Reporting System**: Functionality for Supervisors and Admins to generate and export attendance reports in various formats (Excel, CSV) with customizable date ranges.
- **Class Management**: Tools for Admins to create classes, assign students, and manage class representatives and stakeholders.
- **Multi-Tenancy / Institution Management**: Core functionality allowing the app to support multiple, isolated institutions. Users select their institution upon login, and all data is partitioned accordingly.

# User Experience
- **Design Principles**: The UI will be clean, intuitive, and follow Material Design guidelines. It will be responsive and adaptive, built with Flutter to ensure a native feel on both iOS and Android.
- **Key Screens**:
  - Institution Selection Screen
  - Login/Authentication Screen (after institution selection)
  - Dashboard (with role-specific views)
  - Attendance Taking Interface
  - Student & User Management (Admin-only)
  - Reports and Analytics
- **Navigation**: The app will feature a role-based menu structure, quick access to common features, and effective search/filter capabilities.
</context>
<PRD>
# Technical Architecture
- **Platform**: The application is built with Flutter for both Android and iOS.
- **Architecture**: The project will follow a layered architecture inspired by Clean Architecture, with a clear separation between business logic and UI. The top-level directories will be `core`, `modules`, and `ui`.
- **Folder Structure**:
  ```
  lib/
  ├── core/                 # Shared code: utils, network, error handling, DI setup
  |
  ├── modules/              # DATA and DOMAIN layers, grouped by feature
  │   └── auth/             # Example: Authentication Feature Module
  │       ├── data/
  │       │   ├── datasources/  # Firebase auth datasource
  │       │   ├── models/       # User data model (DTO)
  │       │   └── repositories/ # Auth repository implementation
  │       └── domain/
  │           ├── entities/     # User business object
  │           ├── repositories/ # Abstract auth repository interface
  │           └── usecases/     # Login, logout, get user status usecases
  │
  └── ui/                   # PRESENTATION layer, grouped by feature
      ├── auth/             # Example: Authentication Feature UI
      │   ├── bloc/           # Auth bloc/cubit
      │   ├── screens/        # Login screen, profile screen
      │   └── widgets/        # Custom text fields, login button
      │
      └── shared/           # Common UI components shared across features
          └── widgets/        # e.g., CustomAppBar, LoadingIndicator
  ```
- **State Management**: `flutter_bloc` will be used for state management. Blocs will handle complex business logic and state changes by interacting with use cases from the `modules` directory.
- **Error Handling Strategy**: The `dartz` package will be used to handle errors functionally using the `Either` type.
  - **Data Sources**: Will not contain `try-catch` blocks. They will directly return the result of the remote/local call (e.g., a `Future`).
  - **Repository Implementations**: This is where `try-catch` blocks will be implemented. Methods will catch exceptions (e.g., `FirebaseException`) and return an `Either<Failure, Success>` type. `Left` will contain a `Failure` object (e.g., `ServerFailure`), and `Right` will contain the successful data.
  - **Use Cases**: Will call repository methods and return their `Either` result directly.
  - **Blocs**: Will receive the `Either` type from the use case. They will use the `.fold()` method to handle both the `Failure` (Left) and `Success` (Right) cases, emitting appropriate states for the UI to display (e.g., `ErrorState`, `LoadedState`).
- **Backend Infrastructure**: The system will be built on Firebase, utilizing:
  - **Firebase Authentication**: For user management.
  - **Firestore Database**: For all data storage.
  - **Firebase Storage**: For student profile pictures.
  - **Firebase Functions**: For serverless backend logic (e.g., generating reports).
- **Data Architecture**: A multi-tenant structure will be enforced in Firestore. This will be implemented with a top-level `institutions` collection, with all other data (users, students, classes) stored as subcollections.
- **Security**: Firestore security rules will enforce access control based on user roles and institution.

# Development Roadmap
- **Phase 1: Foundation & Core Features**: Establish the multi-tenant architecture and core user roles. Deliverables include Firebase setup, institution selection, user authentication, basic student/class management (Admin), and foundational UI.
- **Phase 2: Attendance & Reporting**: Implement the primary attendance and reporting functionality. Deliverables include the attendance taking interface, attendance viewing based on roles, a basic dashboard, and Excel/CSV export.
- **Phase 3: Analytics & Advanced Features**: Build out the analytics dashboard and improve user management. Deliverables include an advanced dashboard with charts, full user management for Admins, and offline support for attendance taking.
- **Phase 4: Optimization & Deployment**: Refine the application, optimize performance, and prepare for release. Deliverables include performance profiling, a final security review, end-to-end testing, and preparing app store listings.

# Logical Dependency Chain
1.  **Foundation First**: The absolute first step is establishing the multi-tenant architecture in Firebase and building the institution selection and authentication flow. This is the bedrock upon which everything else is built.
2.  **Visible MVP**: The next logical step is to build the quickest path to a usable feature. This involves creating the flow for an Admin to set up a class and students, and for a Class Representative to take attendance for that class. This makes the core purpose of the app functional and visible early on.
3.  **Build Upon MVP**: Once the core attendance loop is working, features will be layered on top. This includes building out the Supervisor role, developing the reporting and export features, and then creating the analytics dashboard.
4.  **Atomic Features**: Each feature (e.g., user management, reporting, dashboard) will be scoped to be as atomic as possible while still being built upon the foundational dependency chain.

# Risks and Mitigations
- **Technical Challenges**:
  - **Risk**: Complex Firestore queries for analytics across a multi-tenant structure could be slow or require data duplication.
  - **Mitigation**: Design the data model carefully and use Firebase Functions to pre-process or aggregate data for reporting.
  - **Risk**: Ensuring reliable offline data synchronization can be complex.
  - **Mitigation**: Implement a robust local caching strategy and a clear data sync and conflict resolution protocol.
  - **Risk**: Misconfigured Firestore security rules could lead to data leakage between institutions.
  - **Mitigation**: Write extensive tests for all security rules using the Firebase Emulator Suite.
- **MVP Scoping**:
  - **Risk**: The initial MVP scope could become too large, delaying the delivery of a usable product.
  - **Mitigation**: Strictly adhere to the logical dependency chain, focusing only on the core attendance-taking loop for the initial visible product.

# Appendix
- **Security Requirements**: Role-based access control, data encryption in transit and at rest, secure file uploads, and audit logging for sensitive operations.
- **Performance Requirements**: Fast attendance submission (<2 seconds), real-time data sync, and efficient querying for large datasets.
- **Testing Strategy**:
  - **Unit Tests**: For all Blocs/Cubits, use cases, and repository implementations.
  - **Integration Tests**: For critical user flows like login, attendance taking, and ensuring data isolation between tenants.
  - **Mocking**: Use `mockito` or `mocktail` for dependencies.
  - **CI/CD**: A pipeline will be set up to run tests automatically and generate builds.
</PRD>
